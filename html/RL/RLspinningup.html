<!DOCTYPE html><html><head><title>RLspinningup</title><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /><meta http-equiv="Pragma" content="no-cache" /><meta http-equiv="Expires" content="0" /><link rel = "stylesheet" type = "text/css" href = "https://hychn.github.io/style.css" /><meta name="viewport" content="width=device-width, initial-scale=1" /><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://hychn.github.io/tbl_contents.js"></script> </head> <body style="background-color:white;"> <div class="top"><button onclick="toggle_show()">Table of Contents</button> <button onclick="toggle_show_spoiler()">Toggle Spoiler</button>  <button onclick="scroll_bottom()">GOTO END</button> <div id="toc_frame"> <div id="toc"></div> </div> </div>   <div id="contents">
<p>RAPID UNDERSTANDING AND BOND NEUROPLASCITY FORMING
  * repeadtly look at it, re look at it (multiple things at once)
* When I look at different things I feel more motivated. why is this?
Follow the guide of openai, dont fall down too many rabbit hole
Why does model only seek to optimize it's ability to win and not defend?</p>

<h1>Introduction</h1>

<ul>
<li>PART 1: a short introduction to RL terminology, kinds of algorithms, and basic theory,</li>
<li><a href="https://spinningup.openai.com/en/latest/spinningup/keypapers.html">Key Papers in DeepRL</a></li>
<li><a href="https://github.com/openai/spinningup">Code repo of key algo</a></li>
<li><a href="https://spinningup.openai.com/en/latest/spinningup/exercises.html">Excercises</a></li>
</ul>

<h2>ESSAY: Spinning Up as a Deep RL Researcher: https://spinningup.openai.com/en/latest/spinningup/spinningup.html</h2>

<blockquote onclick="click_spoiler(event)" class="spoiler">
  <h3>The Right Background</h3>
  
  <ul>
  <li>Mathematical background 
  <ul>
  <li><strong>random variables, Bayes theorem, chain rule prob, expected value, standard dev, importance sampling</strong></li>
  </ul></li>
  <li>RL main concepts and terminology
  <ul>
  <li><strong>states, actions, trajectories, policies, reward, value functions, action-value functions</strong></li>
  <li>[RL Intro] (https://github.com/jachiam/rl-intro/blob/master/Presentation/rl_intro.pdf)</li>
  <li>[Overview] https://lilianweng.github.io/lil-log/2018/02/19/a-long-peek-into-reinforcement-learning.html</li>
  <li><a href="https://sites.ualberta.ca/~szepesva/papers/RLAlgsInMDPs.pdf">Classical RL algorithms</a></li>
  </ul></li>
  <li>Learn by Doing
  <ul>
  <li>core deep RL algos Simplicity</li>
  </ul></li>
  <li>simplest/smallest implementation first
  <ul>
  <li><a href="https://arxiv.org/abs/1604.06778">Vanilla policy gradient REINFORCE</a></li>
  <li><a href="https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf">DQN</a></li>
  <li><a href="https://blog.openai.com/baselines-acktr-a2c/">A2C</a></li>
  <li><a href="https://arxiv.org/abs/1707.06347">PPO</a></li>
  <li><a href="https://arxiv.org/abs/1509.02971">DDPG</a></li>
  <li>Focus on understanding: 
  <ul>
  <li>writing working RL code requires clear, detail-oriented understanding of the algorithms.</li>
  <li>This is because broken RL code almost always fails silently.</li>
  </ul></li>
  <li>ablations, intuition for parameters or subroutines have the biggest impact</li>
  <li>Don't overfit</li>
  <li>Iterate fast in simple environments: CartPole-v0, InvertedPendulum-v0, FrozenLake-v0, HalfCheetah-v2 (100-250 steps) OpenAI Gym
  <ul>
  <li>Simplest possible toy task</li>
  </ul></li>
  <li>If it doesn't work, assume there is a bug </li>
  <li>Measure everything, replay of agent's performance now and then</li>
  <li>Scale experiments when things work
  ### Developing a Research Project</li>
  <li>Avoid reinventing the wheel
  ### Doing Rigorous Research in RL
  ### Closing Thoughts
  ### PS: Other Resources</li>
  </ul></li>
  </ul>
</blockquote>

<h2>Installation</h2>

<ul>
<li>OpenMPI?</li>
<li>Spinning Up?</li>
</ul>

<h2>Algorithms</h2>

<ul>
<li>Vanilla Policy Gradient (VPG)</li>
<li>Trust Region Policy Optimization (TRPO)</li>
<li>Deep Deterministic Policy Gradient (DDPG)</li>
<li>Twin Delayed DDPG (TD3)</li>
<li>Proximal Policy Optimization (PPO)</li>
<li>Soft Actor-Critic (SAC)</li>
</ul>

<h3>On-Policy Algorithms</h3>

<ul>
<li>VPG -> TRPO -> PPO</li>
<li>on-policy: 
<ul>
<li>don't use old data, weaker on sample efficiency</li>
<li>directly optimize on bjective, policy performance</li>
<li>trades stability  for sample efficiency</li>
</ul></li>
</ul>

<h3>Off-Policy Algorithms</h3>

<ul>
<li>Qlearning -> DDPG -> TD3 -> SAC
<ul>
<li>Bellman's equation for optimality (Q-function) can be trained to satisfy using any environment iteraction data, as long as there is enough experience from high-reward areas in environment)</li>
</ul></li>
<li>sample efficient if it can get the most out of every sample. Humans are very sample efficient. mcst0 is not it needs many examples to learn2play</li>
<li>Importance sampling is a technique to filter these samples</li>
</ul>

<h3>Code Format</h3>

<ul>
<li>algorithm: 
<ul>
<li>class definition for experience buffer object, used to store information from agent-environment interactions</li>
<li>Logger</li>
<li>Random seed setting</li>
<li>Constructing actor-critic Pytorch module via the actor_critic function passed to algorithm function</li>
<li>Instantiate enviroment/experience buffer</li>
<li>set up loss function/ diagnostic</li>
<li>main loop
<ul>
<li>run agent in environment</li>
<li>update parameters of agent</li>
<li>log key performance metrics and save</li>
</ul></li>
</ul></li>
</ul>

<h2>Part 1: Key Concepts in RL (notations)</h2>

<ul>
<li>state:\(s\)</li>
<li>observations:\(o\)</li>
<li>action space: discrete/continuous</li>
<li><p>policy deterministic \(a_t = \mu_\theta(s_t)\) stochastic \(a_t ~ \pi_\theta(.|s_t)\)</p>

<ul>
<li>Deterministic Policies: 
<ul>
<li>like NN model</li>
</ul></li>
<li>Stochastic Policies:
<ul>
<li>Categorical policy (discrete action space) , similar to Categorical NN model</li>
<li>Diagonal Guassian policy (continuous action space)
<ul>
<li><strong>multivariate diagonal distribution</strong></li>
<li>where the <strong>cross variance</strong> is a diagonal matrix</li>
<li>described by mean vector \(\mu\) and convariance matrix \(\sigma\)</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>sampling actions from policy</p></li>
<li><p>computing log likelihoods of particular actions \(log \pi_\theta (a|s)\)</p></li>
<li><p>Trajectories</p></li>
<li><p>Reward </p>

<ul>
<li>finite horizon, infinite horizon discounted return</li>
</ul></li>
<li><p>Goal in RL is to select a policy which maximizes expected return when the agent acts according to it</p></li>
<li><p>\(P(traj|\pi) = \prod_{t=0}^{T-1} p(s_0) p(s_{t+1}| s_t, a_t) \pi(a_t | s_t) \)</p></li>
<li><p>Value Functions</p></li>
<li><p>On-Policy Value Function</p></li>
<li>On-Policy Action-Value Function</li>
<li>Optimal Value Function</li>
<li>Optimal Action-Value Function</li>
</ul>

<p>Link between and Action-Value functions: Taking an action,  why do we need this?</p>

<ul>
<li>Bellman Equations</li>
<li>https://en.wikipedia.org/wiki/Bellman_equation</li>
</ul>

<h1>Opportunities</h1>

<ul>
<li>Open AI Scholars https://openai.com/blog/openai-scholars/ scholars@openai.com</li>
<li><p>Nuts and Bolts of deep rl research: http://joschu.net/docs/nuts-and-bolts.pdf</p>

<h1>Future (Notable sights)</h1></li>
<li><p>monotonic improvement theory (basis of advanced policy gradient algorithms)? http://joschu.net/docs/thesis.pdf</p></li>
<li><p>Model vs Model-Free RL</p>

<ul>
<li>One of the most important branching points in an RL algorithm is the question of whether the agent has access to (or learns) a model of the environment. </li>
<li>By a model of the environment, we mean a function which predicts state transitions and rewards.</li>
</ul></li>
<li><p>Model-Free</p>

<ul>
<li>Policy Optimization \(\pi_\theta(a|s)\)
<ul>
<li>Optimize parameters \(\theta\) on objective \(J(\pi_\theta)\)</li>
</ul></li>
<li>Q-learning
<ul>
<li>Learn approximator \(Q_\theta(s,a)\) for optimal action-value function \(Q^*(s,a)\), the policy is obtained by the supremum policy \(a(s) = argmax_a Q_\theta(s,a)\)</li>
</ul></li>
</ul></li>
<li><p>Trade-offs Between Policy Optimization and Q-Learning. The primary strength of policy optimization methods is that they are principled, in the sense that you directly optimize for the thing you want. This tends to make them stable and reliable. By contrast, Q-learning methods only indirectly optimize for agent performance, by training Q_{\theta} to satisfy a self-consistency equation. There are many failure modes for this kind of learning, so it tends to be less stable. [1] But, Q-learning methods gain the advantage of being substantially more <em>sample efficient</em> when they do work, because they can reuse data more effectively than policy optimization techniques.</p></li>
<li>Interpolating Between Policy Optimization and Q-Learning. Serendipitously, policy optimization and Q-learning are not incompatible (and under some circumstances, it turns out, equivalent), and there exist a range of algorithms that live in between the two extremes. Algorithms that live on this spectrum are able to carefully trade-off between the strengths and weaknesses of either side. Examples include</li>
</ul>

<h1>Policy Optimization</h1>

<ul>
<li>https://spinningup.openai.com/en/latest/spinningup/rl_intro3.html#id16</li>
<li>Policy reward only based on future rewards
<ul>
<li>https://spinningup.openai.com/en/latest/spinningup/extra<em>pg</em>proof1.html</li>
<li>due to the fact that expectation is 0 and this can be formed when t$$ < $$</li>
</ul></li>
<li>https://spinningup.openai.com/en/latest/spinningup/extra<em>pg</em>proof2.html</li>
</ul>

</div></body> </html>
